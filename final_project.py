# -*- coding: utf-8 -*-
"""Final_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-WAFQ1Y5aaIVJVO77beGQiFN_1VpO-5i
"""

from google.colab import drive
drive.mount('/content/drive')
#/content/drive/MyDrive/TIC Trilhas Eldorado/Introdução a Machine Learning/Módulo 4/dataset wine.csv

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score, KFold
from sklearn.preprocessing import StandardScaler, LabelEncoder, label_binarize
from sklearn.metrics import confusion_matrix, classification_report, roc_curve, auc
from sklearn.linear_model import LogisticRegression
from sklearn.multiclass import OneVsRestClassifier
import matplotlib.pyplot as plt
import seaborn as sns
from itertools import cycle

# Load the dataset
wines = pd.read_csv('/content/drive/MyDrive/TIC Trilhas Eldorado/Introdução a Machine Learning/Módulo 4/dataset wine.csv')

# Preview the dataset
pd.set_option('display.max_columns', None)  # Show all columns
pd.set_option('display.float_format', '{:.2f}'.format)  # Format floats to 2 decimal places
print(wines.head().style.set_table_styles(
    [{'selector': 'th', 'props': [('font-size', '12pt'), ('text-align', 'center')]},
     {'selector': 'td', 'props': [('font-size', '12pt'), ('text-align', 'center')]}]))

# Check for missing values
plt.figure(figsize=(10, 7))
sns.heatmap(wines.isnull(), cbar=False, cmap='viridis')
plt.title('Missing Values Heatmap')
plt.show()

# Correlation matrix
plt.figure(figsize=(14, 10))
sns.heatmap(wines.corr(), annot=True, fmt='.2f', cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()

# Use the 'class' column as the label column
label_column = 'class'

# Data preprocessing
label_encoder = LabelEncoder()
wines[label_column] = label_encoder.fit_transform(wines[label_column])

# Split the data into features and target
X = wines.drop(label_column, axis=1)
y = wines[label_column]

# Binarize the target for ROC and AUC calculation
y_bin = label_binarize(y, classes=[0, 1, 2])
n_classes = y_bin.shape[1]

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Normalize the data
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Hyperparameter tuning using OneVsRestClassifier
param_grid = {'estimator__C': [0.01, 0.1, 1, 10, 100]}
grid_search = GridSearchCV(OneVsRestClassifier(LogisticRegression(solver='liblinear', max_iter=5000)), param_grid, cv=5)
grid_search.fit(X_train, y_train)
best_params = grid_search.best_params_
print('Best parameters:', best_params)

# Train the model with the best hyperparameters
best_model = grid_search.best_estimator_
best_model.fit(X_train, y_train)

# Evaluate the model
y_pred = best_model.predict(X_test)
conf_matrix = confusion_matrix(y_test, y_pred)
class_report = classification_report(y_test, y_pred, output_dict=True)
class_report_df = pd.DataFrame(class_report).transpose()

# Visualization of the Confusion Matrix
plt.figure(figsize=(10, 7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

# Visualization of the Classification Report
plt.figure(figsize=(10, 4))
sns.heatmap(class_report_df.iloc[:-1, :].T, annot=True, cmap='Blues', fmt=".2f")
plt.title('Classification Report')
plt.show()

# Binarize the predictions for the ROC curve
y_test_bin = label_binarize(y_test, classes=[0, 1, 2])
y_pred_prob = best_model.predict_proba(X_test)

# ROC curve and AUC for each class
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(n_classes):
    fpr[i], tpr[i], _ = roc_curve(y_test_bin[:, i], y_pred_prob[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

# Plot all ROC curves
plt.figure(figsize=(10, 7))
colors = cycle(['aqua', 'darkorange', 'cornflowerblue'])
for i, color in zip(range(n_classes), colors):
    plt.plot(fpr[i], tpr[i], color=color, lw=2,
             label='ROC curve of class {0} (area = {1:0.2f})'
             ''.format(i, roc_auc[i]))

plt.plot([0, 1], [0, 1], 'k--', lw=2)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) for Multi-Class')
plt.legend(loc="lower right")
plt.show()